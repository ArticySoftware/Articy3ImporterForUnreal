#pragma once

#include "Engine.h"
#include "AssetRegistryModule.h"
#include <sstream>
#include "Dom/JsonValue.h"
#include "UObject/Package.h"
#include "Dom/JsonObject.h"
#include <ObjectTools.h>
#include <AssetToolsModule.h>
#include "ArticyHelpers.h"

namespace ArticyImporterHelpers
{

	// struct to save the data that gets passed in upon the initial import for delayed import.
	// the InParent is a package that gets deleted since no object resides in it. That's why we save the path instead to recreate the package later on
	struct ArticyImportCreationData
	{
		UClass* InClass;
		FString PackageName;
		FName InName;
		EObjectFlags Flags;
		FString Filename;
		const TCHAR* Parms;
		FFeedbackContext* Warn;
		bool bOutOperationCanceled;

		ArticyImportCreationData(UClass* InClass, UObject* InParent,FName InName,EObjectFlags Flags,const FString& Filename, const TCHAR* Parms,FFeedbackContext* Warn,bool bOutOperationCanceled)
		{
			this->InClass = InClass;
			this->PackageName = Cast<UPackage>(InParent)->GetPathName();
			this->InName = InName;
			this->Flags = Flags;
			this->Filename = FString(*Filename);
			this->Parms = Parms;
			this->Warn = Warn;
			this->bOutOperationCanceled = bOutOperationCanceled;
		}

		ArticyImportCreationData()
		{

		}
	};
	inline UPackage* FindOrCreatePackage(const FString Name)
	{
		FString PackageName = ArticyHelpers::ArticyGeneratedFolder / Name;
		UPackage* AssetPackage = CreatePackage(nullptr, *PackageName);
		AssetPackage->FullyLoad();

		return AssetPackage;
	}

	inline bool GetPathToDirectoryOfAsset(UObject* object, FString& outString)
	{
		FString pathName = object->GetOutermost()->GetPathName();
		int32 cutoffIndex = INDEX_NONE;
		pathName.FindLastChar('/', cutoffIndex);

		if (cutoffIndex != INDEX_NONE)
		{
			outString = pathName.Left(cutoffIndex);
			return true;
		}

		return false;
	}

	inline bool GetPackageNameOfDirectoryOfAsset(UObject* object, FString& outString)
	{
		FString packageName;
		GetPathToDirectoryOfAsset(object, packageName);

		int32 cutoffIndex = INDEX_NONE;
		packageName.FindLastChar('/', cutoffIndex);

		if (cutoffIndex != INDEX_NONE)
		{
			outString = packageName.RightChop(cutoffIndex);
			outString.RemoveAt(0);
			return true;
		}

		return false;
	}


	template <typename AssetType>
	AssetType* GenerateAsset(const TCHAR* ClassName, const TCHAR* ModuleName, const FString AssetName = "", const FString SubFolder = "")
	{
		const auto assetName = AssetName.IsEmpty() ? ClassName : AssetName;
		const auto fileName = (SubFolder.IsEmpty() ? assetName : SubFolder / assetName).Replace(TEXT(" "), TEXT("_"));

		auto fullClassName = FString::Printf(TEXT("Class'/Script/%s.%s'"), ModuleName, ClassName);
		auto uclass = ConstructorHelpersInternal::FindOrLoadClass(fullClassName, AssetType::StaticClass());
		if (uclass)
		{
			FAssetRegistryModule& AssetRegistry = FModuleManager::GetModuleChecked<FAssetRegistryModule>("AssetRegistry");

			// this only works for files generated by the packages generator due to the caching happening after DB and GV are generated.
			// This is fine since we only need to handle pre-existing package objects
			const TMap<FString, UArticyObject*> CachedExistingPackageObjects = PackagesGenerator::GetCachedExistingObjects();
			bool objectIsCached = CachedExistingPackageObjects.Contains(assetName);

			UArticyObject* existingObject = nullptr;
			if (objectIsCached)
			{
				existingObject = *CachedExistingPackageObjects.Find(assetName);
			}
	

			auto AssetPackage = FindOrCreatePackage(fileName);

			EObjectFlags Flags = RF_Public | RF_Standalone;

			AssetType* createdAsset = nullptr;
			// if there is no existing object or there is one in the same path with the same class, just create a new asset/update the old asset
			if (!existingObject || (existingObject->GetPathName().Equals(ArticyHelpers::ArticyGeneratedFolder / fileName + TEXT(".") + assetName) && existingObject->UObject::GetClass() == uclass))
			{
				createdAsset = NewObject<AssetType>(AssetPackage, uclass, *assetName, Flags);				
			}
			// if there is an existing cached object with the same name (should be ID in the future probably) + different location 
			// Or same name + same location + different class 
			// create a new one with a temp name, consolidate it, delete the old object and then rename the new one so it's the same as the old one, effectively moving it
			// This also ensures that an update in class (due to template renaming etc.) gets handled properly
			// Direct class references will break, however
			else
			{
				FString packageName;
				FName tempUniqueName = MakeUniqueObjectName(existingObject, uclass, FName(*AssetName));

				FString relativeTempPath = (SubFolder.IsEmpty() ? tempUniqueName.ToString() : SubFolder / tempUniqueName.ToString()).Replace(TEXT(" "), TEXT("_"));
				AssetPackage = FindOrCreatePackage(relativeTempPath);
				createdAsset = NewObject<AssetType>(AssetPackage, uclass, *tempUniqueName.ToString(), Flags);

				UObject* newObject = Cast<UObject>(createdAsset);
				TArray<UObject*> ReplacementObjects;
				ReplacementObjects.Add(existingObject);
				ObjectTools::ConsolidateObjects(newObject, ReplacementObjects, false);


				// Form a filter from the paths
				FARFilter Filter;
				Filter.bRecursivePaths = true;
				Filter.PackagePaths.Emplace(*ArticyHelpers::ArticyGeneratedFolder);
				Filter.ClassNames.Emplace(TEXT("ObjectRedirector"));

				// Query for a list of assets in the selected paths
				TArray<FAssetData> AssetList;
				AssetRegistry.Get().GetAssets(Filter, AssetList);
				TArray<UObjectRedirector*> Redirectors;

				for (FAssetData objectRedirectorData : AssetList)
				{
					UObjectRedirector* redirector = Cast<UObjectRedirector>(objectRedirectorData.GetAsset());
					if (redirector)
					{
						Redirectors.Add(redirector);
					}
				}

				FAssetToolsModule& AssetToolsModule = FModuleManager::LoadModuleChecked<FAssetToolsModule>(TEXT("AssetTools"));
				AssetToolsModule.Get().FixupReferencers(Redirectors);

				FString newDirectoryName;
				GetPathToDirectoryOfAsset(newObject, newDirectoryName);

				TWeakObjectPtr<UObject> weakPtrToObject = newObject;
				FAssetRenameData renameData(weakPtrToObject, newDirectoryName, *assetName);
				TArray<FAssetRenameData> assetsToRename;
				assetsToRename.Add(renameData);

				AssetToolsModule.Get().RenameAssets(assetsToRename);
			}

			if (createdAsset)
			{
				// Notify the asset registry
				FAssetRegistryModule::AssetCreated(Cast<UObject>(createdAsset));

				// Mark the package dirty...
				AssetPackage->MarkPackageDirty();
			}

			return createdAsset;
		}

		//NOTE: cannot use LogArticyRuntime here, causes linker error
		UE_LOG(LogTemp, Error, TEXT("ArticyImporter: Could not find class %s!"), ClassName);

		return nullptr;
	}

	static bool IsPlayInEditor()
	{
		for (const FWorldContext& Context : GEngine->GetWorldContexts())
		{
			if (Context.World()->IsPlayInEditor())
			{
				return true;
			}
		}
		return false;
	}

}
