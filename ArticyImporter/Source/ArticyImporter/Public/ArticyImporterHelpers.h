#pragma once

#include "Engine.h"
#include "AssetRegistryModule.h"
#include <sstream>
#include "Dom/JsonValue.h"
#include "UObject/Package.h"
#include "Dom/JsonObject.h"
#include <ObjectTools.h>
#include <AssetToolsModule.h>
#include "ArticyHelpers.h"

namespace ArticyImporterHelpers
{
	inline UPackage* FindOrCreatePackage(const FString Name)
	{
		FString PackageName = ArticyHelpers::ArticyGeneratedFolder / Name;
		UPackage* AssetPackage = CreatePackage(nullptr, *PackageName);
		AssetPackage->FullyLoad();

		return AssetPackage;
	}

	inline bool GetPathToDirectoryOfAsset(UObject* object, FString& outString)
	{
		FString pathName = object->GetOutermost()->GetPathName();
		int32 cutoffIndex = INDEX_NONE;
		pathName.FindLastChar('/', cutoffIndex);

		if (cutoffIndex != INDEX_NONE)
		{
			outString = pathName.Left(cutoffIndex);
			return true;
		}

		return false;
	}

	inline bool GetPackageNameOfDirectoryOfAsset(UObject* object, FString& outString)
	{
		FString packageName;
		GetPathToDirectoryOfAsset(object, packageName);

		int32 cutoffIndex = INDEX_NONE;
		packageName.FindLastChar('/', cutoffIndex);

		if (cutoffIndex != INDEX_NONE)
		{
			outString = packageName.RightChop(cutoffIndex);
			outString.RemoveAt(0);
			return true;
		}

		return false;
	}


	template <typename AssetType>
	AssetType* GenerateAsset(const TCHAR* ClassName, const TCHAR* ModuleName, const FString AssetName = "", const FString SubFolder = "")
	{
		const auto assetName = AssetName.IsEmpty() ? ClassName : AssetName;
		const auto fileName = (SubFolder.IsEmpty() ? assetName : SubFolder / assetName).Replace(TEXT(" "), TEXT("_"));

		auto fullClassName = FString::Printf(TEXT("Class'/Script/%s.%s'"), ModuleName, ClassName);
		auto uclass = ConstructorHelpersInternal::FindOrLoadClass(fullClassName, AssetType::StaticClass());
		if (uclass)
		{
			FAssetRegistryModule& AssetRegistry = FModuleManager::GetModuleChecked<FAssetRegistryModule>("AssetRegistry");

			// this only works for files generated by the packages generator due to the caching happening after DB and GV are generated.
			// This is fine since we only need to handle pre-existing package objects
			const TMap<FString, UArticyObject*> CachedExistingPackageObjects = PackagesGenerator::GetCachedExistingObjects();
			bool objectIsCached = CachedExistingPackageObjects.Contains(assetName);

			UArticyObject* existingObject = objectIsCached ? *CachedExistingPackageObjects.Find(assetName) : nullptr;
	
			auto assetPackage = FindOrCreatePackage(fileName);

			EObjectFlags Flags = RF_Public | RF_Standalone;

			AssetType* createdAsset = nullptr;
			// if there is no existing object or there is one in the same path with the same class, just create a new asset/update the old asset
			if (!existingObject || (existingObject->GetPathName().Equals(ArticyHelpers::ArticyGeneratedFolder / fileName + TEXT(".") + assetName) && existingObject->UObject::GetClass() == uclass))
			{
				createdAsset = NewObject<AssetType>(assetPackage, uclass, *assetName, Flags);				
			}
			/* if there is an existing cached object with the same name (should be ID in the future probably) + different location 
			 Or same name + same location + different class 
			 create a new one with a temp name, consolidate it, delete the old object and then rename the new one so it's the same as the old one, effectively moving it
			 This also ensures that an update in class (due to template renaming etc.) gets handled properly
			 Direct class references will break, however*/
			else
			{
				FName tempUniqueName = MakeUniqueObjectName(existingObject, uclass, FName(*AssetName));
				FString relativeTempPath = (SubFolder.IsEmpty() ? tempUniqueName.ToString() : SubFolder / tempUniqueName.ToString()).Replace(TEXT(" "), TEXT("_"));

				assetPackage = FindOrCreatePackage(relativeTempPath);
				createdAsset = NewObject<AssetType>(assetPackage, uclass, *tempUniqueName.ToString(), Flags);

				UObject* newObject = Cast<UObject>(createdAsset);
				TArray<UObject*> ReplacementObjects;
				ReplacementObjects.Add(existingObject);
				ObjectTools::ConsolidateObjects(newObject, ReplacementObjects, false);

				// Form a filter from the paths
				FARFilter filter;
				filter.bRecursivePaths = true;
				filter.PackagePaths.Emplace(*ArticyHelpers::ArticyGeneratedFolder);
				filter.ClassNames.Emplace(TEXT("ObjectRedirector"));

				// Query for a list of assets in the selected paths
				TArray<FAssetData> AssetList;
				AssetRegistry.Get().GetAssets(filter, AssetList);
				TArray<UObjectRedirector*> Redirectors;

				for (FAssetData objectRedirectorData : AssetList)
				{
					UObjectRedirector* redirector = Cast<UObjectRedirector>(objectRedirectorData.GetAsset());
					if (redirector)
					{
						Redirectors.Add(redirector);
					}
				}

				FAssetToolsModule& AssetToolsModule = FModuleManager::LoadModuleChecked<FAssetToolsModule>(TEXT("AssetTools"));
				AssetToolsModule.Get().FixupReferencers(Redirectors);

				FString newDirectoryName;
				GetPathToDirectoryOfAsset(newObject, newDirectoryName);

				TWeakObjectPtr<UObject> weakPtrToObject = newObject;
				FAssetRenameData renameData(weakPtrToObject, newDirectoryName, *assetName);

				AssetToolsModule.Get().RenameAssets({ renameData });
			}

			if (createdAsset)
			{
				// Notify the asset registry
				FAssetRegistryModule::AssetCreated(Cast<UObject>(createdAsset));

				// Mark the package dirty...
				assetPackage->MarkPackageDirty();
			}

			return createdAsset;
		}

		//NOTE: cannot use LogArticyRuntime here, causes linker error
		UE_LOG(LogTemp, Error, TEXT("ArticyImporter: Could not find class %s!"), ClassName);

		return nullptr;
	}

	static bool IsPlayInEditor()
	{
		for (const FWorldContext& Context : GEngine->GetWorldContexts())
		{
			if (Context.World()->IsPlayInEditor())
			{
				return true;
			}
		}
		return false;
	}

}
